#!/bin/bash

# Copyright (c) 2014 Kevin Walzer/WordTech Communications LLc

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

man () {

cat > /tmp/ruby2app.1 << EOF 
.\" Text automatically generated by txt2man
.TH ruby2app 1 "03 December 2014" "" ""
.SH NAME
\fBruby2app \fP- bundle Ruby scripts as standalone Mac application
\fB
.SH SYNOPSIS
.nf
.fam C

\fBruby2app\fP [\fB-h\fP]

.fam T
.fi
.fam T
.fi
.SH DESCRIPTION

.TP

\fBruby2app\fP is a simple command-line tool, inspired by similar Mac tools like py2app for Python, that bundles a Ruby script with the Ruby runtime into a standalone Mac application. It reads a basic configuration file to find the appropriate Ruby installation, compiles a small C program that embeds the Ruby interpreter, copies the entire Ruby installation into the application bundle, and re-links the relevant libraries with the main executable.
.SH USAGE

\fBruby2app\fP looks for a Ruby script called "main.rb" to wrap. If a file by that name is not found, the build will fail. 
.PP
\fBruby2app\fP also requires a configuration file in the source directory of your application called "appconfig.cfg." The configuration file must specifies the following keys:
.PP
.nf
.fam C
         RUBY=prefix of Ruby installation to wrap, i.e. /usr/local
         APPNAME=app name
         PLIST=name of application property list file, i.e. Info.plist
         TK=does the applicaiton bundle the Tcl/Tk frameworks, true/false
         ICON=name of application icon file, i.e. "app.icns"

.fam T
.fi
With the config file and "main.rb" in place, run "\fBruby2app\fP" in the source directory, and \fBruby2app\fP will take care of the rest. The result will be a standalone application that does not require Ruby to be installed on the Mac system it is deployed to. 
.PP
If you want to see this user message for \fBruby2app\fP, run "\fBruby2app\fP \fB-h\fP".
.PP
\fBruby2app\fP requires Ruby to be compiled with the "\fB--enable-load-relative\fP" flag. If Ruby is compiled without this flag, it will search a hard-coded path for its libraries and will not run in an application bundle. \fBruby2app\fP's build will fail if it does not find the "\fB--enable-load-relative\fP" flag.
.SH TODO

At present \fBruby2app\fP does not support the inclusion of external libraries in the application bundle except for the Mac-native Tcl/Tk frameworks; this reflects the fact that no other UI toolkit on the Mac is really viable with Ruby. Patches to support additional UI toolkits are welcome.
.PP
There are no current plans to implement \fBruby2app\fP as a gem, or to rewrite it in Ruby. Bash is more than sufficient for this application's tasks, which mostly focus on driving other system tools such as clang, otool, install_name_tool, and cp. 
.SH SEE ALSO

\fBruby\fP(1), \fBinstall_name_tool\fP(1), \fBotool\fP(1), \fBclang\fP(1), \fBcp\fP(1)
.SH AUTHOR

Kevin Walzer, WordTech Communications LLC (kw@codebykevin.com)

EOF

}

usage () {

    cat << EOT

NAME

ruby2app - bundle Ruby scripts as standalone Mac application

SYNOPSIS

ruby2app [-h]

DESCRIPTION

ruby2app is a simple command-line tool, inspired by similar Mac tools like py2app for Python, that bundles a Ruby script with the Ruby runtime into a standalone Mac application. It reads a basic configuration file to find the appropriate Ruby installation, compiles a small C program that embeds the Ruby interpreter, copies the entire Ruby installation into the application bundle, and re-links the relevant libraries with the main executable.  

USAGE

ruby2app looks for a Ruby script called "main.rb" to wrap. If a file by that name is not found, the build will fail. 

ruby2app also requires a configuration file in the source directory of your application called "appconfig.cfg." The configuration file must specifies the following keys:
	
	 RUBY=prefix of Ruby installation to wrap, i.e. /usr/local
	 APPNAME=app name
	 PLIST=name of application property list file, i.e. Info.plist
	 TK=does the applicaiton bundle the Tcl/Tk frameworks, true/false
	 ICON=name of application icon file, i.e. "app.icns"
	 
With the config file and "main.rb" in place, run "ruby2app" in the source directory, and ruby2app will take care of the rest. The result will be a standalone application that does not require Ruby to be installed on the Mac system it is deployed to. 

If you want to see this user message for ruby2app, run "ruby2app -h".

ruby2app requires Ruby to be compiled with the "--enable-load-relative" flag. If Ruby is compiled without this flag, it will search a hard-coded path for its libraries and will not run in an application bundle. ruby2app's build will fail if it does not find the "--enable-load-relative" flag.

TODO

At present ruby2app does not support the inclusion of external libraries in the application bundle except for the Mac-native Tcl/Tk frameworks; this reflects the fact that no other UI toolkit on the Mac is really viable with Ruby. Patches to support additional UI toolkits are welcome.

There are no current plans to implement ruby2app as a gem, or to rewrite it in Ruby. Bash is more than sufficient for this application's tasks, which mostly focus on driving other system tools such as clang, otool, install_name_tool, and cp. 

SEE ALSO

ruby(1), install_name_tool(1), otool(1), clang(1), cp(1)

AUTHOR

Kevin Walzer, WordTech Communications LLC (kw@codebykevin.com)

EOT
}

    while getopts "mh" opt; do
	case $opt in
	    m)
		man; sleep 1; exit 0;
		;;
	    h)
		usage; exit 0;
		;;
	esac
    done

    if  [ ! -f appconfig.cfg ]; then
	echo "App configuration file \"appconfig.cfg\" required. See man ruby2app for details."
	exit 1
    fi


    if  [ ! -f main.rb ]; then
	echo "App file \"main.rb\" required. See man ruby2app for details."
	exit 1
    fi
    
    
. appconfig.cfg

BASELIB=$RUBY/lib
RUBYLIB=$RUBY/lib/ruby
RUBYHEADERS=`$RUBY/bin/ruby -e 'puts RbConfig::CONFIG["rubyhdrdir"]'`
ARCHHEADERS=`$RUBY/bin/ruby -e 'puts RbConfig::CONFIG["rubyarchhdrdir"]'`
RUBYVERSION=`$RUBY/bin/ruby -e 'puts RbConfig::CONFIG["ruby_version"]'`
RUBYLINK=`$RUBY/bin/ruby -e 'puts RbConfig::CONFIG["LIBRUBYARG_SHARED"]'`
DYLIB=`$RUBY/bin/ruby -e 'puts RbConfig::CONFIG["LIBRUBY_SO"]'`
RUBYCONFIG=`$RUBY/bin/ruby -e 'puts RbConfig::CONFIG["configure_args"]'`

if echo $RUBYCONFIG   | grep -e "'--enable-load-relative'";
 then
   echo "Ruby compiled with relative loading. Continuing build."
else
  echo "Ruby must be compiled with the '--enable-load-relative' flag to run in an application bundle."
   exit 1
   fi

if [ -a $APPNAME.app ]
	then
	rm -rf $APPNAME.app
fi

echo "Creating app bundle..."
mkdir $APPNAME.app
mkdir $APPNAME.app/Contents

mkdir $APPNAME.app/Contents/MacOS
mkdir $APPNAME.app/Contents/Resources
mkdir  $APPNAME.app/Contents/Resources/lib

cp $PLIST $APPNAME.app/Contents/Info.plist

if [ $TK == "true" ]
then
    echo "Copying Tcl/Tk frameworks..."
    mkdir $APPNAME.app/Contents/Frameworks
cp -Rf /Library/Frameworks/Tcl.framework $APPNAME.app/Contents/Frameworks/Tcl.framework
cp -Rf /Library/Frameworks/Tk.framework $APPNAME.app/Contents/Frameworks/Tk.framework
fi


if [ -f $ICON ]
then
    echo "Copying app icon..."
    cp $ICON $APPNAME.app/Contents/Resources/$ICON

fi

echo "Begininning build..."

cat << EOT > main.c

#include <ruby/ruby.h>
#include <Carbon/Carbon.h>
#include <CoreFoundation/CoreFoundation.h>
#include <stdlib.h>

int main() {


  // Get a reference to the main bundle
  CFBundleRef mainBundle = CFBundleGetMainBundle();

  // Get a reference to the file's URL
  CFURLRef rubyURL = CFBundleCopyResourceURL(mainBundle, CFSTR("main.rb"), NULL, NULL);

  // Convert the URL reference into a string reference
  CFStringRef rubyPath = CFURLCopyFileSystemPath(rubyURL, kCFURLPOSIXPathStyle);

  // Get the system encoding method
  CFStringEncoding encodingMethod = CFStringGetSystemEncoding();

  // Convert the string reference into a C string
  char *file = CFStringGetCStringPtr(rubyPath, encodingMethod);


  //Now, let's initialize Ruby and pass the script to it.
  ruby_init();

 
  ruby_init_loadpath();

  ruby_script(file); 

  char* options[] = { "", file,};

  void* node=ruby_options(2,options);

  //finally, run the interpreter
  ruby_run_node(node);

  return 0;
 
}

EOT

gcc -Wall -v -o $APPNAME main.c -framework Carbon -framework CoreFoundation -framework Cocoa -I$RUBYHEADERS -I$ARCHHEADERS -L$BASELIB $RUBYLINK

rm main.c

cp $APPNAME $APPNAME.app/Contents/MacOS/$APPNAME
cp main.rb $APPNAME.app/Contents/Resources/main.rb

cp  $BASELIB/$DYLIB $APPNAME.app/Contents/Resources/$DYLIB
cp -R $RUBYLIB $APPNAME.app/Contents/Resources/lib

cd $APPNAME.app/Contents
ln -s Resources lib

cd ../
cd ../

echo "Rewriting link paths..."
LIB=@executable_path/../Resources/lib/$DYLIB

install_name_tool -id $LIB $APPNAME.app/Contents/Resources/$DYLIB

install_name_tool -change $BASELIB/$dylib  $LIB  $APPNAME.app/Contents/MacOS/$APPNAME

find $APPNAME.app/Contents/Resources/lib -name "*.bundle" \
     -exec install_name_tool -change $RUBYLIB \
     $LIB {} \;


if [ $TK == "true" ]

then

find $APPNAME.app/Contents/Resources/lib -name tcltklib.bundle -exec install_name_tool -change  /Library/Frameworks/Tcl.framework/Versions/Current/Tcl @executable_path/../Frameworks/Tcl.framework/Tcl  {} \;

find $APPNAME.app/Contents/Resources/lib -name tcltklib.bundle -exec install_name_tool -change  /Library/Frameworks/Tk.framework/Versions/Current/Tk @executable_path/../Frameworks/Tk.framework/Tk  {} \;

fi

echo "Done."

exit 0
